# Olá, Cargo!

O Cargo é o sistema de construção e gerenciador de pacotes do Rust. A maioria dos Rustaceans usa essa ferramenta para gerenciar seus projetos em Rust, porque o Cargo lida com muitas tarefas para você, como compilar seu código, baixar as bibliotecas de que seu código depende e compilar essas bibliotecas. (Chamamos as bibliotecas que seu código precisa de *dependências*.)

Os programas Rust mais simples, como o que escrevemos até agora, não têm dependências. Se tivéssemos construído o projeto "Olá, mundo!" com o Cargo, ele só usaria a parte do Cargo que lida com a construção do seu código. Conforme você escreve programas Rust mais complexos, adicionará dependências, e se começar um projeto usando o Cargo, adicionar dependências será muito mais fácil de fazer.

Como a grande maioria dos projetos em Rust usa o Cargo, o restante deste livro pressupõe que você também está usando o Cargo. O Cargo é instalado junto com o Rust se você usou os instaladores oficiais mencionados na seção de [“Instalação”][installation]. Se você instalou o Rust por outros meios, verifique se o Cargo está instalado inserindo o seguinte em seu terminal:

```console
$ cargo --version
```

Se você vir um número de versão, você o tem! Se você receber um erro, como "comando não encontrado", consulte a documentação do seu método de instalação para descobrir como instalar o Cargo separadamente.

### Criando um Projeto com Cargo

Vamos criar um novo projeto usando o Cargo e ver como ele difere do nosso projeto original "Hello, world!". Navegue de volta para o seu diretório de *projetos* (ou onde você decidiu armazenar seu código). Em seguida, em qualquer sistema operacional, execute o seguinte:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

O primeiro comando cria um novo diretório e projeto chamado *hello_cargo*. Nomeamos nosso projeto *hello_cargo*, e o Cargo cria seus arquivos em um diretório com o mesmo nome.

Entre no diretório *hello_cargo* e liste os arquivos. Você verá que o Cargo gerou dois arquivos e um diretório para nós: um arquivo *Cargo.toml* e um diretório *src* com um arquivo *main.rs* dentro.

Ele também inicializou um novo repositório Git junto com um arquivo *.gitignore*. Os arquivos do Git não serão gerados se você executar `cargo new` dentro de um repositório Git existente; você pode substituir esse comportamento usando `cargo new --vcs=git`.

> Nota: Git é um sistema de controle de versão comum. Você pode alterar `cargo new` para usar um sistema de controle de versão diferente ou nenhum sistema de controle de versão usando a flag `--vcs`. Execute `cargo new --help` para ver as opções disponíveis.

Abra *Cargo.toml* no seu editor de texto de escolha. Ele deve se parecer com o código no Exemplo 1-2.

<span class="filename">Filename: Cargo.toml</span>

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

<span class="caption">Listing 1-2: Contents of *Cargo.toml* generated by `cargo
new`</span>

Este arquivo está no formato [*TOML*][toml] (*Tom's Obvious, Minimal Language*), que é o formato de configuração do Cargo.

A primeira linha, `[package]`, é um cabeçalho de seção que indica que as declarações seguintes estão configurando um pacote. À medida que adicionamos mais informações a este arquivo, adicionaremos outras seções.

As três linhas seguintes definem as informações de configuração necessárias para que o Cargo compile seu programa: o nome, a versão e a edição do Rust a ser usada. Falaremos sobre a chave `edition` no [Apêndice E][appendix-e].

A última linha, `[dependencies]`, é o início de uma seção na qual você lista quaisquer dependências do seu projeto. Em Rust, pacotes de código são referidos como *crates*. Não precisaremos de outras crates para este projeto, mas as usaremos no primeiro projeto do Capítulo 2, então usaremos esta seção de dependências naquela ocasião.

Agora abra *src/main.rs* e dê uma olhada:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

O Cargo gerou um programa "Hello, world!" para você, assim como o que escrevemos no Exemplo 1-1! Até agora, as diferenças entre nosso projeto e o projeto gerado pelo Cargo são que o Cargo colocou o código no diretório *src* e temos um arquivo de configuração *Cargo.toml* no diretório superior.

O Cargo espera que seus arquivos de origem estejam dentro do diretório *src*. O diretório principal do projeto é apenas para arquivos README, informações de licença, arquivos de configuração e qualquer outra coisa que não esteja relacionada ao seu código. Usar o Cargo ajuda a organizar seus projetos. Há um lugar para tudo, e tudo está em seu lugar.

Se você iniciou um projeto que não usa o Cargo, como fizemos com o projeto "Hello, world!", você pode convertê-lo em um projeto que use o Cargo. Mova o código do projeto para o diretório *src* e crie um arquivo *Cargo.toml* apropriado.

### Construindo e Executando um Projeto com Cargo

Agora, vamos ver o que é diferente ao construir e executar o programa "Olá, mundo!" com o Cargo! A partir do seu diretório *hello_cargo*, construa seu projeto inserindo o seguinte comando:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

Este comando cria um arquivo executável em *target/debug/hello_cargo* (ou *target\debug\hello_cargo.exe* no Windows) em vez de no seu diretório atual. Como a compilação padrão é uma compilação de depuração, o Cargo coloca o binário em um diretório chamado *debug*. Você pode executar o executável com este comando:

```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

Se tudo correr bem, `Hello, world!` deve ser impresso no terminal. Ao executar `cargo build` pela primeira vez, o Cargo também cria um novo arquivo no nível superior: *Cargo.lock*. Este arquivo mantém o controle das versões exatas das dependências em seu projeto. Este projeto não tem dependências, portanto, o arquivo é um pouco escasso. Você nunca precisará alterar este arquivo manualmente; o Cargo gerencia seu conteúdo para você.

Nós acabamos de construir um projeto com `cargo build` e o executamos com `./target/debug/hello_cargo`, mas também podemos usar `cargo run` para compilar o código e depois executar o executável resultante em um único comando:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Usar `cargo run` é mais conveniente do que ter que lembrar de executar `cargo build` e depois usar o caminho completo para o binário, então a maioria dos desenvolvedores usa `cargo run`.

Observe que desta vez não vimos uma saída indicando que o Cargo estava compilando o `hello_cargo`. O Cargo percebeu que os arquivos não haviam mudado, então não reconstruiu, apenas executou o binário. Se você tivesse modificado o seu código fonte, o Cargo teria reconstruído o projeto antes de executá-lo, e você teria visto esta saída:

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

O Cargo também fornece um comando chamado cargo check. Este comando verifica rapidamente o seu código para garantir que ele seja compilado, mas não produz um executável:

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

Por que você não gostaria de um executável? Muitas vezes, `cargo check` é muito mais rápido do que `cargo build`, pois pula a etapa de produção de um executável. Se você estiver verificando continuamente seu trabalho enquanto escreve o código, usar `cargo check` acelerará o processo de informar se seu projeto ainda está compilando! Como tal, muitos Rustaceans executam `cargo check` periodicamente enquanto escrevem seu programa para garantir que ele compile. Em seguida, eles executam `cargo build` quando estão prontos para usar o executável.

Vamos recapitular o que aprendemos até agora sobre o Cargo:

* Podemos criar um projeto usando `cargo new`.
* Podemos construir um projeto usando `cargo build`.
* Podemos construir e executar um projeto em um único passo usando `cargo run`.
* Podemos construir um projeto sem produzir um binário para verificar erros usando `cargo check`.
* Em vez de salvar o resultado da construção no mesmo diretório que nosso código, o Cargo o armazena no diretório *target/debug*.

Uma vantagem adicional do uso do Cargo é que os comandos são os mesmos, independentemente do sistema operacional em que você está trabalhando. Portanto, a partir deste ponto, não forneceremos mais instruções específicas para Linux e macOS em comparação com o Windows.

### Compilando para a Versão Final

Quando seu projeto estiver finalmente pronto para o lançamento, você pode usar `cargo build --release` para compilá-lo com otimizações. Este comando criará um executável em *target/release* em vez de *target/debug*. As otimizações tornam seu código Rust mais rápido, mas ativá-las aumenta o tempo necessário para compilar seu programa. É por isso que existem dois perfis diferentes: um para o desenvolvimento, quando você deseja reconstruir rapidamente e frequentemente, e outro para criar o programa final que será entregue ao usuário e não será reconstruído repetidamente, funcionando o mais rápido possível. Se você estiver fazendo benchmark do tempo de execução do seu código, certifique-se de usar `cargo build --release` e fazer o benchmark com o executável em *target/release*.

### Cargo como Convenção

Em projetos simples, o Cargo não oferece muita vantagem sobre o uso direto do `rustc`, mas ele demonstrará seu valor à medida que seus programas se tornarem mais complexos. Uma vez que os programas cresçam e envolvam vários arquivos ou necessitem de dependências, é muito mais fácil deixar o Cargo coordenar a construção.

Mesmo que o projeto `hello_cargo` seja simples, ele já utiliza grande parte das ferramentas reais que você usará ao longo de sua carreira em Rust. Na verdade, para trabalhar em projetos existentes, você pode usar os seguintes comandos para verificar o código usando o Git, mudar para o diretório do projeto e construí-lo:

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

Para obter mais informações sobre o Cargo, consulte [a documentação dele][cargo].

## Resumo

Você já está no caminho certo em sua jornada em Rust! Neste capítulo, você aprendeu como:

* Instalar a versão estável mais recente do Rust usando `rustup`
* Atualizar para uma versão mais recente do Rust
* Abrir a documentação instalada localmente
* Escrever e executar um programa "Olá, mundo!" usando `rustc` diretamente
* Criar e executar um novo projeto seguindo as convenções do Cargo

Este é um ótimo momento para construir um programa mais substancial para se acostumar a ler e escrever código em Rust. Portanto, no Capítulo 2, construiremos um programa de jogo de adivinhação. Se você preferir começar aprendendo como funcionam os conceitos comuns de programação em Rust, consulte o Capítulo 3 e depois retorne ao Capítulo 2.

[installation]: ch01-01-installation.html#installation
[toml]: https://toml.io
[appendix-e]: appendix-05-editions.html
[cargo]: https://doc.rust-lang.org/cargo/
